from .const import __copyright__, __license__, __version__
from .context_resolver import ContextResolver
from .types import Context, Options, Object, IdentifierIssuer
from typing import Any, Optional, Callable, List

__all__ = [
    '__copyright__', '__license__', '__version__',
    'ContextResolver',
]


def compact(input_: Any, ctx: Context, options: Options) -> Any: ...
def expand(input_: Any, options: Optional[Options]): ...
def flatten(input_: Any, ctx: Optional[Any], options: Optional[Options]): ...
def frame(input_: Any, frame: Any, options: Optional[Options]): ...
def link(input_: Any, ctx: Any, options: Optional[Options]): ...
def normalize(input_: Any, options: Optional[Options]): ...
def from_rdf(input_: Any, options: Optional[Options]): ...
def to_rdf(input_: Any, options: Optional[Options]): ...
def set_document_loader(load_document_: Any) -> None: ...
def get_document_loader(): ...
def sync_document_loader(**kwargs: Any): ...
def async_document_loader(**kwargs: Any): ...
def register_rdf_parser(content_type: Any, parser: Any) -> None: ...
def unregister_rdf_parser(content_type: Any) -> None: ...


class JsonLdProcessor:
    rdf_parsers: Any
    def __init__(self) -> None: ...
    def compact(self, input_: Any, ctx: Context, options: Options): ...
    def expand(self, input_: Any, options: Options): ...
    def flatten(self, input_: Any, ctx: Context, options: Options): ...
    def frame(self, input_: Any, frame: Any, options: Options): ...
    def normalize(self, input_: Any, options: Options): ...
    def from_rdf(self, dataset: Any, options: Options): ...
    def to_rdf(self, input_: Any, options: Options): ...

    def process_context(
        self,
        active_ctx: Context,
        local_ctx: Context,
        options: Options,
    ): ...

    def register_rdf_parser(self, content_type: Any, parser: Any) -> None: ...
    def unregister_rdf_parser(self, content_type: Any) -> None: ...
    @staticmethod
    def has_property(subject: Any, prop: str) -> bool: ...
    @staticmethod
    def has_value(subject: Any, prop: str, value: Any) -> bool: ...
    @staticmethod
    def add_value(subject: Any, property: str, value: Any, options: Options) -> None: ...
    @staticmethod
    def get_values(subject: Any, prop: str) -> List[Any]: ...
    @staticmethod
    def remove_property(subject: Any, prop: str) -> None: ...
    @staticmethod
    def remove_value(subject: Any, property: str, value: Any, options: Options): ...
    @staticmethod
    def compare_values(v1: Any, v2: Any): ...
    @staticmethod
    def get_context_value(ctx: Any, key: Any, type_: Any): ...
    @staticmethod
    def arrayify(value: Any): ...
    @staticmethod
    def _compare_rdf_triples(t1: Any, t2: Any): ...

    def _compact(
        self,
        active_ctx: Context,
        active_property: Any,
        element: Any,
        options: Options,
    ): ...

    def _expand(
        self,
        active_ctx: Context,
        active_property: Any,
        element: Any,
        options: Options,
        inside_list: bool,
        inside_index: bool,
        type_scoped_ctx: Optional[Any]
    ): ...

    def _expand_object(
        self,
        active_ctx: Context,
        active_property: Any,
        expanded_active_property: Any,
        element: Any,
        expanded_parent: Any,
        options: Options,
        inside_list: bool,
        type_key: Optional[Any],
        type_scoped_ctx: Optional[Context],
    ) -> None: ...

    def _flatten(self, input: Any): ...
    def _frame(self, input_: Any, frame: Any, options: Options): ...
    def _from_rdf(self, dataset: Any, options: Options): ...

    def _process_context(
        self,
        active_ctx: Context,
        local_ctx: Any,
        options: Options,
        override_protected: bool,
        propagate: bool,
        validate_scoped: bool,
        cycles: Any,
    ): ...

    def _revert_to_previous_context(self, active_ctx: Context): ...
    def _processing_mode(self, active_ctx: Context, version: Any): ...

    def _check_nest_property(
        self,
        active_ctx: Context,
        nest_property: Any,
    ) -> None: ...

    def _expand_language_map(
        self,
        active_ctx: Context,
        language_map: Any,
        direction: Any,
    ): ...

    def _expand_index_map(
        self,
        active_ctx: Context,
        active_property: str,
        value: Any,
        index_key: Any,
        as_graph: Any,
        property_index: Any,
        options: Options,
    ): ...

    def _expand_value(
        self,
        active_ctx: Context,
        active_property: Any,
        value: Any,
        options: Options,
    ): ...

    def _graph_to_rdf(
        self,
        graph: Any,
        issuer: IdentifierIssuer,
        options: Options,
    ) -> Object[Object[str]]: ...

    def _list_to_rdf(
        self,
        list_: Any,
        issuer: IdentifierIssuer,
        triples: Any,
        rdfDirection: Any,
    ) -> Object[str]: ...

    def _object_to_rdf(
        self,
        item: Any,
        issuer: IdentifierIssuer,
        triples: Any,
        rdfDirection: Any,
    ): ...

    def _rdf_to_object(
        self,
        o: Any,
        use_native_types: bool,
        rdf_direction: Any,
    ): ...

    def _create_node_map(
        self,
        input_: Any,
        graph_map: Any,
        active_graph: Any,
        issuer: Any,
        active_subject: Optional[Any],
        active_property: Optional[str],
        list_: Optional[Any],
    ) -> None: ...

    def _merge_node_map_graphs(self, graph_map: Any): ...

    def _match_frame(
        self,
        state: Any,
        subjects: Any,
        frame: Any,
        parent: Any,
        property: str,
    ) -> None: ...

    def _create_implicit_frame(self, flags: Any): ...

    def _creates_circular_reference(
        self,
        subject_to_embed: Any,
        graph: Any,
        subject_stack: Any,
    ): ...

    def _get_frame_flag(self, frame: Any, options: Options, name: Any): ...
    def _validate_frame(self, frame: Any) -> None: ...
    def _filter_subjects(self, state: Any, subjects: Any, frame: Any, flags: Any): ...
    def _filter_subject(self, state: Any, subject: Any, frame: Any, flags: Any): ...
    def _remove_embed(self, state: Any, id_: Any) -> None: ...
    def _add_frame_output(self, parent: Any, property: Any, output: Any) -> None: ...
    def _node_match(self, state: Any, pattern: Any, value: Any, flags: Any) -> bool: ...
    def _value_match(self, pattern: Any, value: Any) -> bool: ...
    def _cleanup_preserve(self, input_: Any, options: Options): ...
    def _cleanup_null(self, input_: Any, options: Options): ...

    def _select_term(
        self,
        active_ctx: Context,
        iri: Any,
        value: Any,
        containers: Any,
        type_or_language: Any,
        type_or_language_value: Any
    ): ...

    def _compact_iri(
        self,
        active_ctx: Context,
        iri: str,
        value: Optional[Any],
        vocab: bool,
        base: Optional[Any],
        reverse: bool
    ): ...

    def _compact_value(
        self,
        active_ctx: Context,
        active_property: Any,
        value: Any,
        options: Options,
    ): ...

    def _create_term_definition(
        self,
        active_ctx: Context,
        local_ctx: Context,
        term: Any,
        defined: Any,
        options: Options,
        override_protected: bool,
        validate_scoped: bool
    ) -> None: ...

    def _expand_iri(
        self,
        active_ctx: Context,
        value: Any,
        base: Optional[str],
        vocab: bool,
        local_ctx: Optional[Any],
        defined: Optional[Any]
    ): ...

    def _get_initial_context(self, options: Options) -> Context: ...
    def _get_inverse_context(self, active_ctx: Context) -> Context: ...
    def _clone_active_context(self, active_ctx: Context) -> Context: ...


def cmp(a: Any, b: Any) -> int: ...
def _compare_shortest_least(a: Any, b: Any) -> int: ...
def _is_keyword(v: Any) -> bool: ...
def _is_object(v: Any) -> bool: ...
def _is_empty_object(v: Any) -> bool: ...
def _is_array(v: Any) -> bool: ...
def _is_string(v: Any) -> bool: ...
def _validate_type_value(v: Any, is_frame: bool) -> None: ...
def _is_bool(v: Any) -> bool: ...
def _is_integer(v: Any) -> bool: ...
def _is_double(v: Any) -> bool: ...
def _is_numeric(v: Any) -> bool: ...
def _is_subject(v: Any) -> bool: ...
def _is_subject_reference(v: Any) -> bool: ...
def _is_value(v: Any) -> bool: ...
def _is_list(v: Any) -> bool: ...
def _is_graph(v: Any) -> bool: ...
def _is_simple_graph(v: Any) -> bool: ...
def _is_bnode(v: Any) -> bool: ...
def _is_absolute_iri(v: Any) -> bool: ...
def _is_relative_iri(v: Any) -> bool: ...


def load_document(
    url: str,
    options: Options,
    base: Optional[str],
    profile: Optional[str],
    requestProfile: Optional[str],
): ...


def load_html(
    input: Any,
    url: str,
    profile: Optional[str],
    options: Options,
) -> Any: ...


_rdf_parsers: Object[Callable[[str], Object[Any]]]
